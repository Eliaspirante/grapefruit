<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\audio\AudioPlayer.js - gf</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="gf"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AnimatedSprite.html">AnimatedSprite</a></li>
            
                <li><a href="..&#x2F;classes/AssetLoader.html">AssetLoader</a></li>
            
                <li><a href="..&#x2F;classes/AudioLoader.html">AudioLoader</a></li>
            
                <li><a href="..&#x2F;classes/AudioManager.html">AudioManager</a></li>
            
                <li><a href="..&#x2F;classes/AudoPlayer.html">AudoPlayer</a></li>
            
                <li><a href="..&#x2F;classes/Camera.html">Camera</a></li>
            
                <li><a href="..&#x2F;classes/Circle.html">Circle</a></li>
            
                <li><a href="..&#x2F;classes/Clock.html">Clock</a></li>
            
                <li><a href="..&#x2F;classes/DisplayObjectContainer.html">DisplayObjectContainer</a></li>
            
                <li><a href="..&#x2F;classes/Ellipse.html">Ellipse</a></li>
            
                <li><a href="..&#x2F;classes/Emitter.html">Emitter</a></li>
            
                <li><a href="..&#x2F;classes/Game.html">Game</a></li>
            
                <li><a href="..&#x2F;classes/GameState.html">GameState</a></li>
            
                <li><a href="..&#x2F;classes/Gui.html">Gui</a></li>
            
                <li><a href="..&#x2F;classes/GuiItem.html">GuiItem</a></li>
            
                <li><a href="..&#x2F;classes/ImageLayer.html">ImageLayer</a></li>
            
                <li><a href="..&#x2F;classes/Input.html">Input</a></li>
            
                <li><a href="..&#x2F;classes/JsonLoader.html">JsonLoader</a></li>
            
                <li><a href="..&#x2F;classes/Layer.html">Layer</a></li>
            
                <li><a href="..&#x2F;classes/Loader.html">Loader</a></li>
            
                <li><a href="..&#x2F;classes/Map.html">Map</a></li>
            
                <li><a href="..&#x2F;classes/math.html">math</a></li>
            
                <li><a href="..&#x2F;classes/plugin.html">plugin</a></li>
            
                <li><a href="..&#x2F;classes/Point.html">Point</a></li>
            
                <li><a href="..&#x2F;classes/Polygon.html">Polygon</a></li>
            
                <li><a href="..&#x2F;classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="..&#x2F;classes/Sprite.html">Sprite</a></li>
            
                <li><a href="..&#x2F;classes/SpritePool.html">SpritePool</a></li>
            
                <li><a href="..&#x2F;classes/support.html">support</a></li>
            
                <li><a href="..&#x2F;classes/Texture.html">Texture</a></li>
            
                <li><a href="..&#x2F;classes/TextureLoader.html">TextureLoader</a></li>
            
                <li><a href="..&#x2F;classes/Tile.html">Tile</a></li>
            
                <li><a href="..&#x2F;classes/TiledLayer.html">TiledLayer</a></li>
            
                <li><a href="..&#x2F;classes/TiledMap.html">TiledMap</a></li>
            
                <li><a href="..&#x2F;classes/TiledObjectGroup.html">TiledObjectGroup</a></li>
            
                <li><a href="..&#x2F;classes/TiledTileset.html">TiledTileset</a></li>
            
                <li><a href="..&#x2F;classes/utils.html">utils</a></li>
            
                <li><a href="..&#x2F;classes/Vector.html">Vector</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\audio\AudioPlayer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * Grapefruit Audio API, provides an easy interface to use HTML5 Audio
 * The GF Audio API was based on
 * &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;goldfire&#x2F;howler.js&quot;&gt;Howler.js&lt;&#x2F;a&gt;
 *
 * @class AudoPlayer
 * @uses Emitter
 * @constructor
 * @param manager {AudioManager} AudioManager instance for this audio player
 * @param settings {Object} All the settings for this player instance
 *&#x2F;
gf.AudioPlayer = function(manager, settings) {
    &#x2F;&#x2F;mixin the Event Target methods
    gf.Emitter.call(this);

    this.autoplay = false;
    this.buffer = false;
    this.format = null;
    this.loop = false;
    this.pos3d = [0, 0, -0.5];
    this.sprite = {};
    this.src = &#x27;&#x27;;
    &#x2F;&#x2F;volume is getter&#x2F;setter

    this._volume = 1;
    this._duration = 0;
    this._loaded = false;
    this._manager = manager;
    this._canPlay = manager.canPlay;
    this._codecs = manager.codecs;
    this._webAudio = gf.support.webAudio &amp;&amp; !this.buffer;
    this._nodes = [];
    this._onendTimer = [];

    &#x2F;&#x2F;mixin user&#x27;s settings
    gf.utils.setValues(this, settings);

    &#x2F;&#x2F;define volume getter&#x2F;setter
    this.__defineGetter__(&#x27;volume&#x27;, this.getVolume.bind(this));
    this.__defineSetter__(&#x27;volume&#x27;, this.setVolume.bind(this));

    if(this._webAudio) {
        this._setupAudioNode();
    }

    this.load();
};

gf.inherits(gf.AudioPlayer, Object, {
    &#x2F;**
     * Load the audio file for this player
     *
     * @return {AudioPlayer}
     *&#x2F;
    load: function() {
        &#x2F;&#x2F;if using web audio, load up the buffer
        if(this._webAudio) {
            this.loadBuffer(this.src);
        }
        &#x2F;&#x2F;otherwise create some Audio nodes
        else {
            &#x2F;&#x2F;create a new adio node
            var node = new Audio();
            this._nodes.push(node);

            &#x2F;&#x2F;setup the audio node
            node.src = this.src;
            node._pos = 0;
            node.preload = &#x27;auto&#x27;;
            node.volume = this._manager.muted ? 0 : this._volume * this._manager.volume;

            &#x2F;&#x2F;setup the event listener to start playing the sound when it has buffered
            var self = this, evt = function() {
                self._duration = node.duration;

                &#x2F;&#x2F;setup a default sprite
                self.sprite._default = [0, node.duration * 1000];

                &#x2F;&#x2F;check if loaded
                if(!self._loaded) {
                    self._loaded = true;
                    self.emit({
                        type: &#x27;load&#x27;,
                        message: &#x27;Audio file loaded.&#x27;,
                        data: self.src
                    });
                }

                &#x2F;&#x2F;if autoplay then start it
                if(self.autoplay) {
                    self.play();
                }

                &#x2F;&#x2F;clear the event listener
                node.removeEventListener(&#x27;canplaythrough&#x27;, evt, false);
            };
            node.addEventListener(&#x27;canplaythrough&#x27;, evt, false);
            node.load();
        }

        return this;
    },
    &#x2F;**
     * Play a sound from the current time (0 by default).
     *
     * @param sprite {String} (optional) Plays from the specified position in the sound sprite definition.
     * @param callback {Function} (optional) Returns the unique playback id for this sound instance.
     * @return {AudioPlayer}
     *&#x2F;
    play: function(sprite, cb) {
        var self = this;

        if(typeof sprite === &#x27;function&#x27;) {
            cb = sprite;
            sprite = null;
        }

        &#x2F;&#x2F;if no sprite specified, use default
        if(!sprite) {
            sprite = &#x27;_default&#x27;;
        }

        &#x2F;&#x2F;if we haven&#x27;t loaded yet, wait until we do
        if(!this._loaded) {
            this.on(&#x27;load&#x27;, function() {
                self.play(sprite, cb);
            });

            return this;
        }

        &#x2F;&#x2F;if the sprite doesn&#x27;t exist, play nothing
        if(!this.sprite[sprite]) {
            if(typeof cb === &#x27;function&#x27;) cb();
            return this;
        }

        &#x2F;&#x2F;get an audio node to use to play
        this._inactiveNode(function(node) {
            var pos = node._pos &gt; 0 ? node._pos : self.sprite[sprite][0] &#x2F; 1000,
            duration = (self.sprite[sprite][1] &#x2F; 1000) - node._pos,
            loop = (self.loop || self.sprite[sprite][2]),
            soundId = (typeof cb === &#x27;string&#x27;) ? cb : (Math.round(Date.now() * Math.random()) + &#x27;&#x27;),
            timerId;

            node._sprite = sprite;

            &#x2F;&#x2F;after the audio finishes:
            (function(o) {
                timerId = setTimeout(function() {
                    &#x2F;&#x2F;if looping restsart it
                    if(!self._webAudio &amp;&amp; o.loop) {
                        self.stop(o.id, o.timer).play(o.sprite, o.id);
                    }

                    &#x2F;&#x2F; set web audio node to paused
                    if(self._webAudio &amp;&amp; !o.loop) {
                        self._nodeById(o.id).paused = true;
                    }

                    &#x2F;&#x2F;end the track if it is HTML audio and a sprite
                    if(!self._webAudio &amp;&amp; !o.loop) {
                        self.stop(o.id, o.timer);
                    }

                    &#x2F;&#x2F;fire off the end event
                    self.emit({
                        type: &#x27;end&#x27;,
                        message: &#x27;Audio has finished playing&#x27;,
                        data: o.id
                    });
                }, duration * 1000);

                &#x2F;&#x2F;store the timer
                self._onendTimer.push(timerId);

                &#x2F;&#x2F;remember which timer to kill
                o.timer = timerId;
            })({
                id: soundId,
                sprite: sprite,
                loop: loop
            });

            &#x2F;&#x2F;setup webAudio functions
            if(self._webAudio) {
                &#x2F;&#x2F;set the play id to this node and load into context
                node.id = soundId;
                node.paused = false;
                self.refreshBuffer([loop, pos, duration], soundId);
                self._playStart = self._manager.ctx.currentTime;
                node.gain.value = self._volume;

                if(typeof node.bufferSource.start === &#x27;undefined&#x27;) {
                    node.bufferSource.noteGrainOn(0, pos, duration);
                } else {
                    node.bufferSource.start(0, pos, duration);
                }
            } else {
                if(node.readyState === 4) {
                    node.id = soundId;
                    node.currentTime = pos;
                    node.muted = self._manager.muted;
                    node.volume = self._volume * self._manager.volume;
                    node.play();
                } else {
                    self._clearEndTimer(timerId);

                    (function() {
                        var sound = self,
                            playSpr = sprite,
                            fn = cb,
                            newNode = node;

                        var evt = function() {
                            sound.play(playSpr, fn);

                            &#x2F;&#x2F;clear listener
                            newNode.removeEventListener(&#x27;canplaythrough&#x27;, evt, false);
                        };
                        newNode.addEventListener(&#x27;canplaythrough&#x27;, evt, false);
                    })();

                    return self;
                }
            }

            self.emit({
                type: &#x27;play&#x27;,
                message: &#x27;Playing audio file&#x27;,
                data: soundId
            });

            if(typeof cb === &#x27;function&#x27;)
                cb(soundId);
        });

        return this;
    },
    &#x2F;**
     * Pause playback and save the current position.
     *
     * @param id {String} (optional) The play instance ID.
     * @param timerId {String} (optional) Clear the correct timeout ID.
     * @return {AudioPlayer}
     *&#x2F;
    pause: function(id, timerId) {
        var self = this;

        &#x2F;&#x2F;if we haven&#x27;t loaded this sound yet, wait until we play it to pause it
        if(!this._loaded) {
            this.on(&#x27;play&#x27;, function() {
                self.play(id);
            });

            return this;
        }

        &#x2F;&#x2F;clear the onend timer
        this._clearEndTimer(timerId || 0);

        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if(activeNode) {
            if(this._webAudio) {
                &#x2F;&#x2F;ensure the sound was created
                if(!activeNode.bufferSource)
                    return this;

                activeNode.paused = true;
                activeNode._pos += this._manager.ctx.currentTime - this._playStart;

                if(typeof activeNode.bufferSource.stop === &#x27;undefined&#x27;) {
                    activeNode.bufferSource.noteOff(0);
                } else {
                    activeNode.bufferSource.stop(0);
                }
            } else {
                activeNode._pos = activeNode.currentTime;
                activeNode.pause();
            }
        }

        this.emit({
            type: &#x27;pause&#x27;,
            message: &#x27;Audio file paused&#x27;,
            data: id
        });

        return this;
    },
    &#x2F;**
     * Stop playback and reset to start.
     *
     * @param id {String} (optional) The play instance ID.
     * @param timerId {String} (optional) Clear the correct timeout ID.
     * @return {AudioPlayer}
     *&#x2F;
    stop: function(id, timerId) {
        var self = this;

        &#x2F;&#x2F;if we haven&#x27;t loaded this sound yet, wait until we play it to stop it
        if(!this._loaded) {
            this.on(&#x27;play&#x27;, function() {
                self.stop(id);
            });

            return this;
        }

        &#x2F;&#x2F;clear onend timer
        this._clearEndTimer(timerId || 0);

        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if(activeNode) {
            activeNode._pos = 0;

            if(this._webAudio) {
                if(!activeNode.bufferSource)
                    return this;

                activeNode.paused = true;

                if(typeof activeNode.bufferSource.stop === &#x27;undefined&#x27;) {
                    activeNode.bufferSource.noteOff(0);
                } else {
                    activeNode.bufferSource.stop(0);
                }
            } else {
                activeNode.pause();
                activeNode.currentTime = 0;
            }
        }

        return this;
    },
    &#x2F;**
     * Mute this sound.
     *
     * @param id {String} (optional) The play instance ID.
     * @return {AudioPlayer}
     *&#x2F;
    mute: function(id) {
        return this.setMuted(true, id);
    },
    &#x2F;**
     * Unmute this sound.
     *
     * @param id {String} (optional) The play instance ID.
     * @return {AudioPlayer}
     *&#x2F;
    unmute: function(id) {
        return this.setMuted(false, id);
    },
    &#x2F;**
     * Set the muted state of this sound.
     *
     * @param id {String} (optional) The play instance ID.
     * @return {AudioPlayer}
     *&#x2F;
    setMuted: function(muted, id) {
        var self  = this;

        &#x2F;&#x2F;if we haven&#x27;t loaded this sound yet, wait until we play it to mute it
        if(!this._loaded) {
            this.on(&#x27;play&#x27;, function() {
                self.setMuted(muted, id);
            });

            return this;
        }

        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if(activeNode) {
            if(this._webAudio) {
                activeNode.gain.value = muted ? 0 : this._volume;
            } else {
                activeNode.volume =  muted ? 0 : this._volume;
            }
        }

        return this;
    },
    &#x2F;**
     * Set the position of playback.
     *
     * @param pos {Number} The position to move current playback to.
     * @param id {String} (optional) The play instance ID.
     * @return {AudioPlayer}
     *&#x2F;
    seek: function(pos, id) {
        var self = this;

        &#x2F;&#x2F;if we haven&#x27;t loaded this sound yet, wait until it is to seek it
        if(!this._loaded) {
            this.on(&#x27;load&#x27;, function() {
                self.seek(pos);
            });

            return this;
        }

        &#x2F;&#x2F;if position is &lt; 0, or invalid, then set to 0
        if(!pos || pos &lt; 0)
            pos = 0;

        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if(activeNode) {
            if(this._webAudio) {
                activeNode._pos = pos;
                this.pause(activeNode.id).play(activeNode._sprite, id);
            } else {
                activeNode.currentTime = pos;
            }
        }

        return this;
    },
    &#x2F;**
     * Get the position of playback.
     *
     * @param id {String} (optional) The play instance ID.
     * @return {Number}
     *&#x2F;
    getPosition: function(id) {
        var self = this;

        &#x2F;&#x2F;if we haven&#x27;t loaded this sound yet, wait until it is to seek it
        if(!this._loaded) {
            this.on(&#x27;load&#x27;, function() {
                self.getPosition(id);
            });

            return this;
        }

        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if(activeNode) {
            if(this._webAudio) {
                return activeNode._pos + (this._manager.ctx.currentTime - this._playStart);
            } else {
                return activeNode.currentTime;
            }
        }

        return 0;
    },
    &#x2F;**
     * Fade a currently playing sound between two volumes.
     *
     * @param from {Number} The volume to fade from (0.0 to 1.0).
     * @param to {Number} The volume to fade to (0.0 to 1.0).
     * @param len {Number} Time in milliseconds to fade.
     * @param id {String} (optional) The play instance ID.
     * @param callback {Function} (optional) Fired when the fade is complete.
     * @return {AudioPlayer}
     *&#x2F;
    fade: function(from, to, len, id, cb) {
        var self = this,
            diff = Math.abs(from - to),
            dir = from &gt; to ? &#x27;dowm&#x27; : &#x27;up&#x27;,
            steps = diff &#x2F; 0.01,
            stepTime = len &#x2F; steps;

        if(typeof id === &#x27;function&#x27;) {
            cb = id;
            id = null;
        }

        &#x2F;&#x2F;if we haven&#x27;t loaded this sound yet, wait until it is to seek it
        if(!this._loaded) {
            this.on(&#x27;load&#x27;, function() {
                self.fade(from, to, len, id, cb);
            });

            return this;
        }

        this.setVolume(from, id);

        for(var i = 1; i &lt;= steps; ++i) {
            var change = this._volume + ((dir === &#x27;up&#x27; ? 0.01 : -0.01) * i),
                vol = Math.round(1000 * change) &#x2F; 1000,
                wait = stepTime * i;

            this._doFadeStep(vol, wait, to, id, cb);
        }
    },
    &#x2F;**
     * Returns the current volume of the player
     *
     * @method getVolume
     * @return {Number} The current volume
     *&#x2F;
    getVolume: function() {
        return this._volume;
    },
    &#x2F;**
     * Sets the current volume of the player
     *
     * @method setVolume
     * @param vol {Number} The current volume
     * @param id {String} (optional) The play instance ID.
     * @return {AudioPlayer}
     *&#x2F;
    setVolume: function(vol, id) {
        var self = this;

        &#x2F;&#x2F; make sure volume is a number
        vol = parseFloat(vol);

        &#x2F;&#x2F;if we haven&#x27;t loaded this sound yet, wait until we play it to change the volume
        if(!this._loaded) {
            this.on(&#x27;play&#x27;, function() {
                self.setVolume(vol, id);
            });

            return this;
        }

        &#x2F;&#x2F;set the volume
        if(vol &gt;= 0 &amp;&amp; vol &lt;= 1) {
            this._volume = vol;

            var activeNode = id ? this._nodeById(id) : this._activeNode();
            if(activeNode) {
                if(this._webAudio) {
                    activeNode.gain.volume = vol;
                } else {
                    activeNode.volume = vol * this._manager.volume;
                }
            }
        }

        return this;
    },
    &#x2F;**
     * Set the 3D position of the audio source.
     * The most common usage is to set the &#x27;x&#x27; position
     * to affect the left&#x2F;right ear panning. Setting any value higher than
     * 1.0 will begin to decrease the volume of the sound as it moves further away.
     * NOTE: This only works with Web Audio API, HTML5 Audio playback
     * will not be affected.
     *
     * @param x {Number} The x-position of the playback from -1000.0 to 1000.0
     * @param y {Number} The y-position of the playback from -1000.0 to 1000.0
     * @param z {Number} The z-position of the playback from -1000.0 to 1000.0
     * @param id {String} (optional) The play instance ID.
     * @return {AudioPlayer}
     *&#x2F;
    setPosition: function(x, y, z, id) {
        var self = this;

        &#x2F;&#x2F;set a default for the optional &#x27;y&#x27; and &#x27;z&#x27;
        x = !x ? 0 : x;
        y = !y ? 0 : y;
        z = (!z &amp;&amp; z !== 0) ? -0.5 : z;

        &#x2F;&#x2F;if we haven&#x27;t loaded this sound yet, wait until we play it to change the position
        if(!this._loaded) {
            this.on(&#x27;play&#x27;, function() {
                self.setPosition(x, y, z, id);
            });

            return this;
        }

        if(this._webAudio) {
            var activeNode = id ? this._nodeById(id) : this._activeNode();
            if(activeNode) {
                this.pos3d[0] = x;
                this.pos3d[1] = y;
                this.pos3d[2] = z;
                activeNode.panner.setPosition(x, y, z);
            }
        }

        return this;
    },
    _doFadeStep: function(vol, wait, end, id, cb) {
        var self = this;

        setTimeout(function() {
            self.setVolume(vol, id);

            if(vol === end) {
                if(typeof cb === &#x27;function&#x27;)
                    cb();
            }
        }, wait);
    },
    &#x2F;**
     * Get an audio node by ID.
     *
     * @return {AudioPlayer} Audio node.
     *&#x2F;
    _nodeById: function(id) {
        var node = this._nodes[0]; &#x2F;&#x2F;default return value

        &#x2F;&#x2F;find the node with this ID
        for(var i = 0, il = this._nodes.length; i &lt; il; ++i) {
            if(this._nodes[i].id === id) {
                node = this._nodes[i];
                break;
            }
        }

        return node;
    },
    &#x2F;**
     * Get the first active audio node.
     *
     * @return {Howl} Audio node.
     *&#x2F;
    _activeNode: function() {
        var node;

        &#x2F;&#x2F;find the first playing node
        for(var i = 0, il = this._nodes.length; i &lt; il; ++i) {
            if(!this._nodes[i].paused) {
                node = this._nodes[i];
                break;
            }
        }

        &#x2F;&#x2F;remove excess inactive nodes
        this._drainPool();

        return node;
    },
    &#x2F;**
     * Get the first inactive audio node.
     * If there is none, create a new one and add it to the pool.
     *
     * @param  {Function} callback Function to call when the audio node is ready.
     *&#x2F;
    _inactiveNode: function(cb) {
        var node;

        &#x2F;&#x2F;find first inactive node to recycle
        for(var i = 0, il = this._nodes.length; i &lt; il; ++i) {
            if(this._nodes[i].paused &amp;&amp; this._nodes[i].readyState === 4) {
                cb(node = this._nodes[i]);
                break;
            }
        }

        &#x2F;&#x2F;remove excess inactive nodes
        this._drainPool();

        if(node) return;

        &#x2F;&#x2F;create new node if there are no inactives
        if(this._webAudio) {
            node = this._setupAudioNode();
            cb(node);
        } else {
            this.load();
            node = this._nodes[this.nodes.length - 1];
            node.addEventListener(&#x27;loadedmetadata&#x27;, function() {
                cb(node);
            });
        }
    },
    &#x2F;**
     * If there are more than 5 inactive audio nodes in the pool, clear out the rest.
     *&#x2F;
    _drainPool: function() {
        var inactive = 0,
            i = 0, il = 0;

        &#x2F;&#x2F;count inactive nodes
        for(i = 0, il = this._nodes.length; i &lt; il; ++i) {
            if(this._nodes[i].paused) {
                inactive++;
            }
        }

        &#x2F;&#x2F;remove excess inactive nodes
        for(i = this._nodes.length; i &gt;= 0; --i) {
            if(inactive &lt;= 5)
                break;

            if(this._nodes[i].paused) {
                inactive--;
                this._nodes.splice(i, 1);
            }
        }
    },
    &#x2F;**
     * Clear &#x27;onend&#x27; timeout before it ends.
     * @param  {Number} timerId The ID of the sound to be cancelled.
     *&#x2F;
    _clearEndTimer: function(timerId) {
        var timer = this._onendTimer.indexOf(timerId);

        &#x2F;&#x2F;make sure the timer is cleared
        timer = timer &gt;= 0 ? timer : 0;

        if(this._onendTimer[timer]) {
            clearTimeout(this._onendTimer[timer]);
            this._onendTimer.splice(timer, 1);
        }
    },
    &#x2F;**
     * Setup the gain node and panner for a Web Audio instance.
     * @return {Object} The new audio node.
     *&#x2F;
    _setupAudioNode: function() {
        var node = this._nodes,
            i = this._nodes.length;

        &#x2F;&#x2F;create gain node
        node.push((typeof this._manager.ctx.createGain === &#x27;undefined&#x27;) ? this._manager.ctx.createGainNode : this._manager.ctx.createGain());
        node[i].gain.value = this._volume;
        node[i].paused = true;
        node[i]._pos = 0;
        node[i].readyState = 4;
        node[i].connect(this._manager.masterGain);

        &#x2F;&#x2F;create the panner
        node[i].panner = this._manager.ctx.createPanner();
        node[i].panner.setPosition(this.pos3d[0], this.pos3d[1], this.pos3d[2]);
        node[i].panner.connect(node[i]);

        return node[i];
    }
});

&#x2F;&#x2F;define some prototype functions that are only available when using the WebAudio API
if(gf.support.webAudio) {
    &#x2F;**
     * Buffer a sound from URL (or from cache) and decode to audio source (Web Audio API).
     *
     * @param url {String} The path to the sound file.
     *&#x2F;
    gf.AudioPlayer.prototype.loadBuffer = function(url) {
        &#x2F;&#x2F;load from cache
        if(url in gf.assetCache) {
            this._duration = gf.assetCache[url].duration;
            this.loadSound();
        } else {
            &#x2F;&#x2F;load the buffer from the URL
            var self = this;

            gf.utils.ajax({
                method: &#x27;GET&#x27;,
                url: url,
                dataType: &#x27;arraybuffer&#x27;,
                load: function(data) {
                    &#x2F;&#x2F;decode the buffer into an audio source
                    self._manager.ctx.decodeAudioData(data, function(buffer) {
                        if(buffer) {
                            gf.assetCache[url] = buffer;
                            self.loadSound(buffer);
                        }
                    });
                },
                error: function() {
                    &#x2F;&#x2F;if there was an error, switch to HTML Audio
                    if(self._webAudio) {
                        self._buffer = true;
                        self._webAudio = false;
                        self._nodes = [];
                        self.load();
                    }
                }
            });
        }
    };

    &#x2F;**
     * Finishes loading the Web Audio API sound and fires the loaded event
     *
     * @param buffer {Object} The decoded buffer sound source.
     *&#x2F;
    gf.AudioPlayer.prototype.loadSound = function(buffer) {
        this._duration = buffer ? buffer.duration : this._duration;

        &#x2F;&#x2F;setup a default sprite
        this.sprite._default = [0, this._duration * 1000];

        &#x2F;&#x2F;fire the load event
        if(!this._loaded) {
            this._loaded = true;
            this.emit({
                type: &#x27;load&#x27;,
                message: &#x27;Audio file loaded.&#x27;,
                data: this.src
            });
        }

        &#x2F;&#x2F;autoplay is appropriate
        if(this.autoplay) {
            this.play();
        }
    };

    &#x2F;**
     * Load the sound back into the buffer source.
     *
     * @param  {Array}  loop  Loop boolean, pos, and duration.
     * @param  {String} id    (optional) The play instance ID.
     *&#x2F;
    gf.AudioPlayer.prototype.refreshBuffer = function(loop, id) {
        var node = this._nodeById(id);

        &#x2F;&#x2F;setup the buffer source for playback
        node.bufferSource = this._manager.ctx.createBufferSource();
        node.bufferSource.buffer = gf.assetCache[this.src];
        node.bufferSource.connect(node.panner);
        node.bufferSource.loop = loop[0];

        if(loop[0]) {
            node.bufferSource.loopStart = loop[1];
            node.bufferSource.loopEnd = loop[1] + loop[2];
        }
    };
}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
