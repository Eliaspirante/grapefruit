<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\map\tiled\TiledLayer.js - gf</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="gf"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AnimatedSprite.html">AnimatedSprite</a></li>
            
                <li><a href="..&#x2F;classes/AssetLoader.html">AssetLoader</a></li>
            
                <li><a href="..&#x2F;classes/AudioLoader.html">AudioLoader</a></li>
            
                <li><a href="..&#x2F;classes/AudioManager.html">AudioManager</a></li>
            
                <li><a href="..&#x2F;classes/AudoPlayer.html">AudoPlayer</a></li>
            
                <li><a href="..&#x2F;classes/Camera.html">Camera</a></li>
            
                <li><a href="..&#x2F;classes/Circle.html">Circle</a></li>
            
                <li><a href="..&#x2F;classes/Clock.html">Clock</a></li>
            
                <li><a href="..&#x2F;classes/DisplayObjectContainer.html">DisplayObjectContainer</a></li>
            
                <li><a href="..&#x2F;classes/Ellipse.html">Ellipse</a></li>
            
                <li><a href="..&#x2F;classes/Emitter.html">Emitter</a></li>
            
                <li><a href="..&#x2F;classes/Game.html">Game</a></li>
            
                <li><a href="..&#x2F;classes/GameState.html">GameState</a></li>
            
                <li><a href="..&#x2F;classes/Gui.html">Gui</a></li>
            
                <li><a href="..&#x2F;classes/GuiItem.html">GuiItem</a></li>
            
                <li><a href="..&#x2F;classes/ImageLayer.html">ImageLayer</a></li>
            
                <li><a href="..&#x2F;classes/Input.html">Input</a></li>
            
                <li><a href="..&#x2F;classes/JsonLoader.html">JsonLoader</a></li>
            
                <li><a href="..&#x2F;classes/Layer.html">Layer</a></li>
            
                <li><a href="..&#x2F;classes/Loader.html">Loader</a></li>
            
                <li><a href="..&#x2F;classes/Map.html">Map</a></li>
            
                <li><a href="..&#x2F;classes/math.html">math</a></li>
            
                <li><a href="..&#x2F;classes/plugin.html">plugin</a></li>
            
                <li><a href="..&#x2F;classes/Point.html">Point</a></li>
            
                <li><a href="..&#x2F;classes/Polygon.html">Polygon</a></li>
            
                <li><a href="..&#x2F;classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="..&#x2F;classes/Sprite.html">Sprite</a></li>
            
                <li><a href="..&#x2F;classes/SpritePool.html">SpritePool</a></li>
            
                <li><a href="..&#x2F;classes/support.html">support</a></li>
            
                <li><a href="..&#x2F;classes/Texture.html">Texture</a></li>
            
                <li><a href="..&#x2F;classes/TextureLoader.html">TextureLoader</a></li>
            
                <li><a href="..&#x2F;classes/Tile.html">Tile</a></li>
            
                <li><a href="..&#x2F;classes/TiledLayer.html">TiledLayer</a></li>
            
                <li><a href="..&#x2F;classes/TiledMap.html">TiledMap</a></li>
            
                <li><a href="..&#x2F;classes/TiledObjectGroup.html">TiledObjectGroup</a></li>
            
                <li><a href="..&#x2F;classes/TiledTileset.html">TiledTileset</a></li>
            
                <li><a href="..&#x2F;classes/utils.html">utils</a></li>
            
                <li><a href="..&#x2F;classes/Vector.html">Vector</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\map\tiled\TiledLayer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * The TiledLayer is the visual tiled layer that actually displays on the screen
 *
 * This class will be created by the TiledMap, there shouldn&#x27;t be a reason to
 * create an instance on your own.
 *
 * @class TiledLayer
 * @extends Layer
 * @constructor
 * @param layer {Object} All the settings for the layer
 *&#x2F;
&#x2F;&#x2F;see: https:&#x2F;&#x2F;github.com&#x2F;GoodBoyDigital&#x2F;pixi.js&#x2F;issues&#x2F;48
gf.TiledLayer = function(layer) {
    gf.Layer.call(this, layer);

    &#x2F;**
     * The tile IDs of the tilemap
     *
     * @property name
     * @type Uint32Array
     *&#x2F;
    this.tileIds = gf.support.typedArrays ? new Uint32Array(layer.data) : layer.data;

    &#x2F;**
     * The current map of all tiles on the screen
     *
     * @property tiles
     * @type Object
     *&#x2F;
    this.tiles = {};

    &#x2F;**
     * The user-defined properties of this group. Usually defined in the TiledEditor
     *
     * @property properties
     * @type Object
     *&#x2F;
    this.properties = layer.properties || {};

    &#x2F;&#x2F;translate some tiled properties to our inherited properties
    this.position.x = layer.x;
    this.position.y = layer.y;
    this.alpha = layer.opacity;
    this.visible = layer.visible;

    this._tilePool = [];
    this._buffered = { left: false, right: false, top: false, bottom: false };
    this._panDelta = new gf.Vector(0, 0);
    this._rendered = new gf.Rectangle(0, 0, 0, 0);
};

gf.inherits(gf.TiledLayer, gf.Layer, {
    &#x2F;**
     * Creates all the tile sprites needed to display the layer
     *
     * @method renderTiles
     * @param startX {Number} The starting x tile position
     * @param startY {Number} The starting y tile position
     * @param numX {Number} The number of tiles in the X direction to render
     * @param numY {Number} The number of tiles in the Y direction to render
     *&#x2F;
    renderTiles: function(startX, startY, numX, numY) {
        &#x2F;&#x2F;clear all the visual tiles
        this.clearTiles();

        &#x2F;&#x2F;ensure we don&#x27;t go below 0
        startX = startX &lt; 0 ? 0 : startX;
        startY = startY &lt; 0 ? 0 : startY;

        &#x2F;&#x2F;ensure we don&#x27;t go outside the map size
        var endX = (startX + numX &lt;= this.parent.size.x) ? startX + numX : (this.parent.size.x - startX);
        var endY = (startY + numY &lt;= this.parent.size.y) ? startY + numY : (this.parent.size.y - startY);

        &#x2F;&#x2F;render new sprites
        for(var x = startX; x &lt; endX; ++x) {
            for(var y = startY; y &lt; endY; ++y) {
                this.moveTileSprite(x, y, x, y);
            }
        }

        &#x2F;&#x2F;set rendered area
        this._rendered.x = startX;
        this._rendered.y = startY;
        this._rendered.width = endX - startX;
        this._rendered.height = endY - startY;
        this._updateRenderSq();

        &#x2F;&#x2F;reset buffered status
        this._buffered.left = this._buffered.right = this._buffered.top = this._buffered.bottom = false;

        &#x2F;&#x2F;reset panDelta
        this._panDelta.x = this.parent.position.x % this.parent.scaledTileSize.x;
        this._panDelta.y = this.parent.position.y % this.parent.scaledTileSize.y;
    },
    &#x2F;**
     * Clears all the tiles currently used to render the layer
     *
     * @method clearTiles
     *&#x2F;
    clearTiles: function() {
        &#x2F;&#x2F;hide&#x2F;free each tile and remove from the memory map
        for(var x in this.tiles) {
            for(var y in this.tiles[x]) {
                var tile = this.tiles[x][y];

                if(tile) {
                    &#x2F;&#x2F;hide&#x2F;free the sprite
                    tile.visible = false;
                    tile.disablePhysics();
                    this._tilePool.push(tile);
                }

                &#x2F;&#x2F;remove the Y key
                delete this.tiles[x][y];
            }

            &#x2F;&#x2F;keep the X key so we dont have to recreate these objects
            &#x2F;&#x2F;delete this.tiles[x];
        }
    },
    &#x2F;**
     * Moves a tile sprite from one position to another, and creates a new tile
     * if the old position didn&#x27;t have a sprite
     *
     * @method moveTileSprite
     * @param fromTileX {Number} The x coord of the tile in units of tiles (not pixels) to move from
     * @param fromTileY {Number} The y coord of the tile in units of tiles (not pixels) to move from
     * @param toTileX {Number} The x coord of the tile in units of tiles (not pixels) to move to
     * @param toTileY {Number} The y coord of the tile in units of tiles (not pixels) to move to
     * @return {PIXI.Sprite} The sprite to display
     *&#x2F;
    moveTileSprite: function(fromTileX, fromTileY, toTileX, toTileY) {
        var tile,
            id = (toTileX + (toTileY * this.size.x)),
            tileId = this.tileIds[id],
            set = this.parent.getTileset(tileId),
            iso = (this.parent.orientation === &#x27;isometric&#x27;),
            texture,
            props,
            position,
            hitArea,
            interactive;

        &#x2F;&#x2F;if no tileset, just ensure the &quot;from&quot; tile is put back in the pool
        if(!set) {
            if(this.tiles[fromTileX] &amp;&amp; this.tiles[fromTileX][fromTileY]) {
                var t = this.tiles[fromTileX][fromTileY];
                this.tiles[fromTileX][fromTileY] = null;

                t.visible = false;
                this._tilePool.push(t);
            }
            return;
        }

        &#x2F;&#x2F;grab some values for the tile
        texture = set.getTileTexture(tileId);
        props = set.getTileProperties(tileId);
        hitArea = props.hitArea || set.properties.hitArea;
        interactive = this._getInteractive(set, props);
        position = iso ?
            &#x2F;&#x2F; Isometric position
            [
                (toTileX * (this.parent.tileSize.x &#x2F; 2)) - (toTileY * (this.parent.tileSize.x &#x2F; 2)) + set.tileoffset.x,
                (toTileY * (this.parent.tileSize.y &#x2F; 2)) + (toTileX * (this.parent.tileSize.y &#x2F; 2)) + set.tileoffset.y
            ]
            :
            &#x2F;&#x2F; Orthoganal position
            [
                (toTileX * this.parent.tileSize.x) + set.tileoffset.x,
                (toTileY * this.parent.tileSize.y) + set.tileoffset.y
            ];

        &#x2F;&#x2F;due to the fact that we use top-left anchors for everything, but tiled uses bottom-left
        &#x2F;&#x2F;we need to move the position of each tile down by a single map-tile height. That is why
        &#x2F;&#x2F;there is an addition of &quot;this.parent.tileSize.y&quot; to the coords
        position[1] +=  this.parent.tileSize.y;

        &#x2F;&#x2F;if there is one to move in the map, lets just move it
        if(this.tiles[fromTileX] &amp;&amp; this.tiles[fromTileX][fromTileY]) {
            tile = this.tiles[fromTileX][fromTileY];
            this.tiles[fromTileX][fromTileY] = null;
        }
        &#x2F;&#x2F;otherwise grab a new tile from the pool
        else {
            tile = this._tilePool.pop();
        }

        &#x2F;&#x2F;if we couldn&#x27;t find a tile from the pool, or one to move
        &#x2F;&#x2F;then create a new tile
        if(!tile) {
            tile = new gf.Tile(texture);
            tile.mass = Infinity;
            tile.anchor.y = 1;
            this.addChild(tile);
        }

        if(props.isCollidable)
            tile.enablePhysics(this.parent.parent.physics); &#x2F;&#x2F;this.TiledMap.GameState.physics

        tile.setTexture(texture);
        tile.setPosition(position[0], position[1]);

        tile.setInteractive(interactive);

        tile.collisionType = props.type;
        tile.visible = true;
        tile.hitArea = hitArea;

        &#x2F;&#x2F;pass through all events
        if(interactive) {
            tile.click = this.onTileEvent.bind(this, &#x27;click&#x27;, tile);
            tile.mousedown = this.onTileEvent.bind(this, &#x27;mousedown&#x27;, tile);
            tile.mouseup = this.onTileEvent.bind(this, &#x27;mouseup&#x27;, tile);
            tile.mousemove = this.onTileEvent.bind(this, &#x27;mousemove&#x27;, tile);
            tile.mouseout = this.onTileEvent.bind(this, &#x27;mouseout&#x27;, tile);
            tile.mouseover = this.onTileEvent.bind(this, &#x27;mouseover&#x27;, tile);
            tile.mouseupoutside = this.onTileEvent.bind(this, &#x27;mouseupoutside&#x27;, tile);
        }

        &#x2F;&#x2F;update sprite position in the map
        if(!this.tiles[toTileX])
            this.tiles[toTileX] = {};

        this.tiles[toTileX][toTileY] = tile;

        return tile;
    },
    onTileEvent: function(eventName, tile, data) {
        this.parent.onTileEvent(eventName, tile, data);
    },
    _getInteractive: function(set, o) {
        var v;

        &#x2F;&#x2F;first check the lowest level value (on the tile iteself)
        if(o.interactive !== undefined || o.interactiveTiles !== undefined)
            v = o;
        &#x2F;&#x2F;next check if the tileset has the value
        else if(set &amp;&amp; (set.properties.interactive !== undefined || set.properties.interactiveTiles !== undefined))
            v = set.properties;
        &#x2F;&#x2F;next check if this layer has interactive tiles
        else if(this.properties.interactive !== undefined || this.properties.interactiveTiles !== undefined)
            v = this.properties;
        &#x2F;&#x2F;finally check if the map as a whole has interactive tiles
        else if(this.parent.properties.interactive !== undefined || this.parent.properties.interactiveTiles !== undefined)
            v = this.parent.properties;

        &#x2F;&#x2F;see if anything has a value to use
        if(v) {
            &#x2F;&#x2F;if they do, lets grab what the interactive value is
            return !!(v.interactive || v.interactiveTiles);
        }

        return false;
    },
    &#x2F;**
     * Pans the layer around, rendering stuff if necessary
     *
     * @method pan
     * @param dx {Number|Point} The x amount to pan, if a Point is passed the dy param is ignored
     * @param dy {Number} The y ammount to pan
     * @return {Layer} Returns itself for chainability
     *&#x2F;
    pan: function(dx, dy) {
        this._panDelta.x += dx;
        this._panDelta.y += dy;

        &#x2F;&#x2F;check if we need to build a buffer around the viewport
        &#x2F;&#x2F;usually this happens on the first pan after a full render

        &#x2F;&#x2F;moving world right, so left will be exposed
        if(dx &gt; 0 &amp;&amp; !this._buffered.left)
            this._renderLeft(this._buffered.left = true);
        &#x2F;&#x2F;moving world left, so right will be exposed
        else if(dx &lt; 0 &amp;&amp; !this._buffered.right)
            this._renderRight(this._buffered.right = true);
        &#x2F;&#x2F;moving world down, so top will be exposed
        else if(dy &gt; 0 &amp;&amp; !this._buffered.top)
            this._renderUp(this._buffered.top = true);
        &#x2F;&#x2F;moving world up, so bottom will be exposed
        else if(dy &lt; 0 &amp;&amp; !this._buffered.bottom)
            this._renderDown(this._buffered.bottom = true);

        &#x2F;&#x2F;moved position right, so render left
        while(this._panDelta.x &gt;= this.parent.scaledTileSize.x) {
            this._renderLeft();
            this._panDelta.x -= this.parent.scaledTileSize.x;
        }

        &#x2F;&#x2F;moved position left, so render right
        while(this._panDelta.x &lt;= -this.parent.scaledTileSize.x) {
            this._renderRight();
            this._panDelta.x += this.parent.scaledTileSize.x;
        }

        &#x2F;&#x2F;moved position down, so render up
        while(this._panDelta.y &gt;= this.parent.scaledTileSize.y) {
            this._renderUp();
            this._panDelta.y -= this.parent.scaledTileSize.y;
        }

        &#x2F;&#x2F;moved position up, so render down
        while(this._panDelta.y &lt;= -this.parent.scaledTileSize.y) {
            this._renderDown();
            this._panDelta.y += this.parent.scaledTileSize.y;
        }
    },
    _renderLeft: function(forceNew) {
        &#x2F;&#x2F;move all the far right tiles to the left side
        for(var i = 0; i &lt; this._rendered.height; ++i) {
            this.moveTileSprite(
                forceNew ? -1 : this._rendered.right,
                forceNew ? -1 : this._rendered.top + i,
                this._rendered.left - 1,
                this._rendered.top + i
            );
        }
        this._rendered.x--;
        if(forceNew) this._rendered.width++;
        this._updateRenderSq();
    },
    _renderRight: function(forceNew) {
        &#x2F;&#x2F;move all the far left tiles to the right side
        for(var i = 0; i &lt; this._rendered.height; ++i) {
            this.moveTileSprite(
                forceNew ? -1 : this._rendered.left,
                forceNew ? -1 : this._rendered.top + i,
                this._rendered.right + 1,
                this._rendered.top + i
            );
        }
        if(!forceNew) this._rendered.x++;
        if(forceNew) this._rendered.width++;
        this._updateRenderSq();
    },
    _renderUp: function(forceNew) {
        &#x2F;&#x2F;move all the far bottom tiles to the top side
        for(var i = 0; i &lt; this._rendered.width; ++i) {
            this.moveTileSprite(
                forceNew ? -1 : this._rendered.left + i,
                forceNew ? -1 : this._rendered.bottom,
                this._rendered.left + i,
                this._rendered.top - 1
            );
        }
        this._rendered.y--;
        if(forceNew) this._rendered.height++;
        this._updateRenderSq();
    },
    _renderDown: function(forceNew) {
        &#x2F;&#x2F;move all the far top tiles to the bottom side
        for(var i = 0; i &lt; this._rendered.width; ++i) {
            this.moveTileSprite(
                forceNew ? -1 : this._rendered.left + i,
                forceNew ? -1 : this._rendered.top,
                this._rendered.left + i,
                this._rendered.bottom + 1
            );
        }
        if(!forceNew) this._rendered.y++;
        if(forceNew) this._rendered.height++;
        this._updateRenderSq();
    },
    _updateRenderSq: function() {
        this._rendered.left = this._rendered.x;
        this._rendered.right = this._rendered.x + this._rendered.width - 1;
        this._rendered.top = this._rendered.y;
        this._rendered.bottom = this._rendered.y + this._rendered.height - 1;
    }
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
