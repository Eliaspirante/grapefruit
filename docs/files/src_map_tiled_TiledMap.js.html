<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\map\tiled\TiledMap.js - gf</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="gf"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.3</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AssetLoader.html">AssetLoader</a></li>
            
                <li><a href="..&#x2F;classes/AudoPlayer.html">AudoPlayer</a></li>
            
                <li><a href="..&#x2F;classes/Camera.html">Camera</a></li>
            
                <li><a href="..&#x2F;classes/Clock.html">Clock</a></li>
            
                <li><a href="..&#x2F;classes/debug.html">debug</a></li>
            
                <li><a href="..&#x2F;classes/DisplayObject.html">DisplayObject</a></li>
            
                <li><a href="..&#x2F;classes/Entity.html">Entity</a></li>
            
                <li><a href="..&#x2F;classes/entityPool.html">entityPool</a></li>
            
                <li><a href="..&#x2F;classes/EventTarget.html">EventTarget</a></li>
            
                <li><a href="..&#x2F;classes/game.html">game</a></li>
            
                <li><a href="..&#x2F;classes/Gui.html">Gui</a></li>
            
                <li><a href="..&#x2F;classes/GuiItem.html">GuiItem</a></li>
            
                <li><a href="..&#x2F;classes/Hud.html">Hud</a></li>
            
                <li><a href="..&#x2F;classes/HudItem.html">HudItem</a></li>
            
                <li><a href="..&#x2F;classes/Input.html">Input</a></li>
            
                <li><a href="..&#x2F;classes/Layer.html">Layer</a></li>
            
                <li><a href="..&#x2F;classes/Map.html">Map</a></li>
            
                <li><a href="..&#x2F;classes/plugin.html">plugin</a></li>
            
                <li><a href="..&#x2F;classes/Point.html">Point</a></li>
            
                <li><a href="..&#x2F;classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="..&#x2F;classes/Sprite.html">Sprite</a></li>
            
                <li><a href="..&#x2F;classes/support.html">support</a></li>
            
                <li><a href="..&#x2F;classes/Texture.html">Texture</a></li>
            
                <li><a href="..&#x2F;classes/TiledLayer.html">TiledLayer</a></li>
            
                <li><a href="..&#x2F;classes/TiledMap.html">TiledMap</a></li>
            
                <li><a href="..&#x2F;classes/TiledObjectGroup.html">TiledObjectGroup</a></li>
            
                <li><a href="..&#x2F;classes/TiledTileset.html">TiledTileset</a></li>
            
                <li><a href="..&#x2F;classes/utils.html">utils</a></li>
            
                <li><a href="..&#x2F;classes/Vector.html">Vector</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\map\tiled\TiledMap.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * Tiled map, expects a Tiled TMX file loaded by the gf.loader as the argument.
 * The loader knows to load all textures and other resources when loading a world TMX
 * file, and this expets that to already be done.
 *
 * @class TiledMap
 * @extends Map
 * @constructor
 * @param map {Object} All the settings for the map
 *&#x2F;
gf.TiledMap = function(game, map) {
    gf.Map.call(this, game, map);

    this.scale.x = parseInt(map.properties.scale, 10) || 1;
    this.scale.y = parseInt(map.properties.scale, 10) || 1;

    &#x2F;**
     * The tile size
     *
     * @property tileSize
     * @type Vector
     *&#x2F;
    this.tileSize = new gf.Vector(
        map.tilewidth,
        map.tileheight
    );

    &#x2F;**
     * The scaled tile size
     *
     * @property scaledTileSize
     * @type Vector
     *&#x2F;
    this.scaledTileSize = new gf.Vector(
        map.tilewidth * this.scale.x,
        map.tileheight * this.scale.y
    );

    &#x2F;**
     * The user-defined properties
     *
     * @property properties
     * @type Object
     * @default {}
     *&#x2F;
    this.properties = map.properties || {};

    &#x2F;**
     * The real size (size * scaledTileSize)
     *
     * @property realSize
     * @type Vector
     *&#x2F;
    this.realSize = new gf.Vector(
        this.size.x * this.scaledTileSize.x,
        this.size.y * this.scaledTileSize.y
    );

    &#x2F;**
     * The orientation of the map, currently only &#x27;orthogonal&#x27; is supported
     *
     * @property orientation
     * @type String
     *&#x2F;
    this.orientation = map.orientation;

    &#x2F;**
     * The tilesets used by this map
     *
     * @property tilesets
     * @type Array
     *&#x2F;
    this.tilesets = [];

    &#x2F;**
     * The tileset for the collision layer
     *
     * @property collisionTileset
     * @type TiledTileset
     *&#x2F;
    this.collisionTileset = null;

    for(var t = 0, tl = map.tilesets.length; t &lt; tl; ++t) {
        var len = this.tilesets.push(new gf.TiledTileset(map.tilesets[t]));

        if(this.tilesets[len-1].name.toLowerCase().indexOf(&#x27;collider&#x27;) === 0)
            this.collisionTileset = this.tilesets[len-1];
    }

    &#x2F;**
     * The layer for collisions
     *
     * @property collisionLayer
     * @type Array
     *&#x2F;
    this.collisionLayer = [];

    &#x2F;**
     * The version of this map
     *
     * @property version
     * @type String
     *&#x2F;
    this.version = map.version;

    &#x2F;&#x2F;create the layers
    var numX = Math.ceil(this.game.renderer.view.width &#x2F; this.scaledTileSize.x),
        numY = Math.ceil(this.game.renderer.view.height &#x2F; this.scaledTileSize.y);

    for(var i = 0, il = map.layers.length; i &lt; il; ++i) {
        var lyr;

        switch(map.layers[i].type) {
            case &#x27;tilelayer&#x27;:
                lyr = new gf.TiledLayer(map.layers[i]);
                this.addChild(lyr);

                &#x2F;&#x2F;lyr.scale = this.scale;
                lyr.renderTiles(
                    Math.floor(this.position.x &#x2F; this.tileSize.x),
                    Math.floor(this.position.y &#x2F; this.tileSize.y),
                    numX,
                    numY
                );

                if(lyr.name.toLowerCase().indexOf(&#x27;collision&#x27;) === 0) {
                    this.collisionLayer = lyr;

                    if(!gf.debug.showMapColliders)
                        lyr.visible = false;
                }
                break;

            case &#x27;objectgroup&#x27;:
                lyr = new gf.TiledObjectGroup(map.layers[i]);
                this.addChild(lyr);

                &#x2F;&#x2F;auto spawn the player object group
                if(lyr.name === &#x27;player&#x27; &amp;&amp; !lyr.properties.manual)
                    lyr.spawn();
        }
    }
};

gf.inherits(gf.TiledMap, gf.Map, {
    &#x2F;**
     * Gets the tileset that an ID is associated with
     *
     * @method getTileset
     * @param tileId {Number} The id of the tile to find the tileset for
     * @return {TiledTileset}
     *&#x2F;
    getTileset: function(tileId) {
        for(var i = 0, il = this.tilesets.length; i &lt; il; ++i)
            if(tileId &gt;= this.tilesets[i].firstgid &amp;&amp; tileId &lt;= this.tilesets[i].lastgid)
                return this.tilesets[i];
    },
    &#x2F;**
     * Checks an entities collision with the collision layer of this map
     *
     * @method checkCollision
     * @param ent {Entity} The entity to check
     * @param sz {Vector} The size of the entity
     * @param pv {Vector} The potential movement vector
     *&#x2F;
    &#x2F;&#x2F;see: http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;2576412&#x2F;tile-map-collision-detection
    checkCollision: function(ent, pv) {
        if(!this.collisionLayer || !this.collisionTileset || (pv.x === 0 &amp;&amp; pv.y === 0))
            return [];

        if(gf.debug._showColliders &amp;&amp; !this.sprites) {
            this.sprites = new gf.ObjectPool(PIXI.Sprite, this);
        }

        &#x2F;&#x2F;collider overlays
        if(gf.debug._showColliders) {
            this.sprites.freeAll();
            for(var s = 0; s &lt; this.sprites.pool.length; ++s)
                this.sprites.pool[s].visible = false;
        }

            &#x2F;&#x2F;get movement vector and normalize as our step
        var step = pv.clone().normalize(),
            pos = ent.position,
            width = ent.currentAnim ? ent.currentAnim.width : pos.x,
            height = ent.currentAnim ? ent.currentAnim.height : pos.y,
            i = 0,
            il = 0,
            tile = null,
            res = [];

        &#x2F;&#x2F;scan along the right face of the bound box
        if(step.x &gt; 0) {
            for(i = pos.y, il = pos.y + height; i &lt; il; ++i) {
                tile = this._checkPoint(
                    new gf.Point(
                        pos.x + width,
                        i
                    ),
                    step,
                    pv,
                    &#x27;x&#x27;
                );
                if(tile) break;
            }
        }
        &#x2F;&#x2F;scan along the left face of the bound box
        else if(step.x &lt; 0) {
            for(i = pos.y, il = pos.y + height; i &lt; il; ++i) {
                tile = this._checkPoint(
                    new gf.Point(
                        pos.x,
                        i
                    ),
                    step,
                    pv,
                    &#x27;x&#x27;
                );
                if(tile) break;
            }
        }

        if(tile) {
            res.push(tile);
            tile = null;
        }

        &#x2F;&#x2F;scan along the bottom face of the bound box
        if(step.y &gt; 0) {
            for(i = pos.x, il = pos.x + width; i &lt; il; ++i) {
                tile = this._checkPoint(
                    new gf.Point(
                        i,
                        pos.y + height
                    ),
                    step,
                    pv,
                    &#x27;y&#x27;
                );
                if(tile) break;
            }
        }
        &#x2F;&#x2F;scan along the top face of the bound box
        else if(step.y &lt; 0) {
            for(i = pos.x, il = pos.x + width; i &lt; il; ++i) {
                tile = this._checkPoint(
                    new gf.Point(
                        i,
                        pos.y
                    ),
                    step,
                    pv,
                    &#x27;y&#x27;
                );
                if(tile) break;
            }
        }

        if(tile) {
            res.push(tile);
            tile = null;
        }

        return res;
    },
    _showCollider: function(id, cell) {
        var text = this.collisionTileset.getTileTexture(id);
        if(text) {
            var spr = this.sprites.create(text);
            spr.position.x = cell.x * this.tileSize.x;
            spr.position.y = cell.y * this.tileSize.y;
            spr.alpha = 0.5;
            spr.visible = true;
            spr.setTexture(text);
        }
    },
    _checkPoint: function(start, step, pv, ax) {
        step = step.clone();

        &#x2F;&#x2F;end location
        var end = new gf.Point(
            (start.x + pv.x),
            (start.y + pv.y)
        ),
        &#x2F;&#x2F;original cell location
        cell = new gf.Point(
            Math.floor(start.x &#x2F; this.tileSize.x),
            Math.floor(start.y &#x2F; this.tileSize.y)
        ),
        &#x2F;&#x2F;end cell
        endCell = new gf.Point(
            Math.floor(end.x &#x2F; this.tileSize.x),
            Math.floor(end.y &#x2F; this.tileSize.y)
        ),
        &#x2F;&#x2F;the distance between 2 consectutive vertical lines
        tDelta = new gf.Vector(
            this.tileSize.x &#x2F; Math.abs(step.x),
            this.tileSize.y &#x2F; Math.abs(step.y)
        ),
        &#x2F;&#x2F;temp and return vars
        tMax = new gf.Point(),
        id = 0,
        tile = null;

        if(end.x &gt; start.x) {
            tMax.x = step.x === 0 ? 0 : ((cell.x + 1) * this.tileSize.x - start.x) &#x2F; step.x;
        } else {
            tMax.x = step.x === 0 ? 0 : (cell.x * this.tileSize.x - start.x) &#x2F; step.x;
        }

        if(end.y &gt; start.y) {
            tMax.y = step.y === 0 ? 0 : ((cell.y + 1) * this.tileSize.y - start.y) &#x2F; step.y;
        } else {
            tMax.y = step.y === 0 ? 0 : (cell.y * this.tileSize.y - start.y) &#x2F; step.y;
        }

        &#x2F;&#x2F;ceil afterwards so tDelta and tMax are correct
        step.x = step.x &lt; 0 ? Math.floor(step.x) : Math.ceil(step.x);
        step.y = step.y &lt; 0 ? Math.floor(step.y) : Math.ceil(step.y);

        &#x2F;&#x2F;check the cell currently on
        id = this.collisionLayer.tiles[(cell.x + (cell.y * this.collisionLayer.size.x))];
        tile = this.collisionTileset.getTileProperties(id);
        if(tile &amp;&amp; tile.isCollidable) {
            if(gf.debug._showColliders)
                this._showCollider(id, cell);

            return { axis: ax, tile: tile };
        }

        &#x2F;&#x2F;scan all the tiles along the movement vector
        while(cell.x !== endCell.x || cell.y !== endCell.y) {
            if(tMax.x &lt; tMax.y) {
                tMax.x += tDelta.x;
                cell.x += step.x;
                ax = &#x27;x&#x27;;
            } else {
                tMax.y += tDelta.y;
                cell.y += step.y;
                ax = &#x27;y&#x27;;
            }

            id = this.collisionLayer.tiles[(cell.x + (cell.y * this.collisionLayer.size.x))];
            tile = this.collisionTileset.getTileProperties(id);
            if(tile &amp;&amp; tile.isCollidable) {
                if(gf.debug._showColliders)
                    this._showCollider(id, cell);

                return { axis: ax, tile: tile };
            }
        }
    },
    &#x2F;**
     * Notifies the map it needs to resize, re renders the viewport
     *
     * @method resize
     * @private
     *&#x2F;
    resize: function() {
        var numX = Math.ceil(this.game.renderer.view.width &#x2F; this.scaledTileSize.x),
            numY = Math.ceil(this.game.renderer.view.height &#x2F; this.scaledTileSize.y);

        for(var i = 0, il = this.children.length; i &lt; il; ++i) {
            var o = this.children[i];

            if(o instanceof gf.TiledLayer &amp;&amp; o.visible) {
                o.renderTiles(
                    Math.floor(this.position.x &#x2F; this.scaledTileSize.x),
                    Math.floor(this.position.y &#x2F; this.scaledTileSize.y),
                    numX,
                    numY
                );
            }
        }
    },
    forEachEntity: function(fn) {
        &#x2F;&#x2F;go through each object group and call for each entity. This is slightly more efficient
        &#x2F;&#x2F;than the generic DisplayObject version since we can skip over checking all the TiledLayers
        &#x2F;&#x2F;which will never have any Entities in them.
        for(var i = 0, il = this.children.length; i &lt; il; ++i) {
            if(this.children[i] instanceof gf.TiledObjectGroup)
                this.children[i].forEachEntity(fn);
        }
    },
    &#x2F;&#x2F;WIP
    _checkHalfBlock: function(half, x, y) {
        var tx = Math.floor(x &#x2F; this.scaledTileSize.x) * this.scaledTileSize.x,
            ty = Math.floor(y &#x2F; this.scaledTileSize.y) * this.scaledTileSize.y,
            midX = tx + ((this.scaledTileSize.x) &#x2F; 2),
            endX = tx + (this.scaledTileSize.x),
            midY = ty - ((this.scaledTileSize.y) &#x2F; 2),
            endY = ty - (this.scaledTileSize.y);

        switch(half) {
            case gf.types.HALF.LEFT:
                return (x &gt; tx &amp;&amp; x &lt; midX);

            case gf.types.HALF.RIGHT:
                return (x &gt; midX &amp;&amp; x &lt; endX);

            case gf.types.HALF.TOP:
                return (y &gt; midY &amp;&amp; y &lt; ty);

            case gf.types.HALF.BOTTOM:
                return (y &gt; endY &amp;&amp; y &lt; midY);
        }

        return false;
    }
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
